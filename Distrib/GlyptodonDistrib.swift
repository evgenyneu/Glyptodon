//
// Glyptodon
//
// A UI widget for displaying 'no results' message in iOS
//
// https://github.com/exchangegroup/glyptodon
//
// This file was automatically generated by combining multiple Swift source files.
//


// ----------------------------
//
// Glyptodon.swift
//
// ----------------------------


import UIKit

/**

Coordinates the process of showing and hiding of the message view.

The instance is created automatically in the `glyptodon` property of any UIView instance.
It is not expected to be instantiated manually anywhere except unit tests.

For example:

let view = UIView()
view.glyptodon.show("No messages")

*/
final class Glyptodon: GlyptodonInterface {
  private weak var superview: UIView!
  
  init(superview: UIView) {
    self.superview = superview
  }
  
  /**
  
  Shows the message view.
  
  - parameter message: The text message to be shown.
  
  */
  func show(message: String) {
    let view = GlyptodonView()
    view.showInSuperview(superview, withMessage: message)
  }
  
  /// Hide the message window if it's currently open.
  func hide() {
    
  }
}


// ----------------------------
//
// GlyptodonInterface.swift
//
// ----------------------------

import UIKit

/**

Coordinates the process of showing and hiding of the view.

The instance is created automatically in the `glyptodon` property of any UIView instance.
It is not expected to be instantiated manually anywhere except unit tests.

For example:

let view = UIView()
view.glyptodon.show("No messages")

*/
public protocol GlyptodonInterface: class {
  /**
  
  Shows the message view.
  
  - parameter message: The text message to be shown.
  
  */
  func show(message: String)
  
  /// Hide the message window if it's currently open.
  func hide()
}


// ----------------------------
//
// GlyptodonView.swift
//
// ----------------------------

import UIKit

class GlyptodonView: UIView {
  func showInSuperview(superview: UIView, withMessage message: String) {
    superview.addSubview(self)
    addLayoutConstraints()
    createLabel(message)
    style()
  }
  
  private func createLabel(message: String) {
    let label = UILabel()
    label.text = message
    label.font = UIFont.preferredFontForTextStyle(UIFontTextStyleBody)
    label.textColor = UIColor.redColor()
    label.textAlignment = .Center
    
    addSubview(label)
    addLabelLayoutConstraints(label)
  }
  
  private func style() {
    backgroundColor = UIColor.grayColor()
  }
  
  private func addLayoutConstraints() {
    guard let superview = superview else { return }
    
    translatesAutoresizingMaskIntoConstraints = false
    
    TegAutolayoutConstraints.fillParent(self, parentView: superview, margin: 0, vertically: true)
    TegAutolayoutConstraints.fillParent(self, parentView: superview, margin: 0, vertically: false)
  }
  
  private func addLabelLayoutConstraints(label: UILabel) {
    label.translatesAutoresizingMaskIntoConstraints = false
    TegAutolayoutConstraints.fillParent(label, parentView: self, margin: 20, vertically: false)
    TegAutolayoutConstraints.centerY(label, viewTwo: self, constraintContainer: self)
  }
}


// ----------------------------
//
// UIView+Glyptodon.swift
//
// ----------------------------

import UIKit

private var sabAssociationKey: UInt8 = 0

/**

UIView extension for showing a 'no results' message.

let view = UIView()
view.glyptodon.show("Shopping cart is empty")

*/
public extension UIView {
  /**
  
  Message bar extension.
  Call `glyptodon.show`, `glyptodon.hide` functions to show a message widget in the view.
  
  let view = UIView()
  view.glyptodon.show("Shopping cart is empty")
  
  */
  public var glyptodon: GlyptodonInterface {
    get {
      if let value = objc_getAssociatedObject(self, &sabAssociationKey) as? GlyptodonInterface {
        return value
      } else {
        let glyptodon = Glyptodon(superview: self)
        
        objc_setAssociatedObject(self, &sabAssociationKey, glyptodon,
          objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
        
        return glyptodon
      }
    }
    
    set {
      objc_setAssociatedObject(self, &sabAssociationKey, newValue,
        objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
    }
  }
}


// ----------------------------
//
// TegAutolayoutConstraints.swift
//
// ----------------------------

//
//  TegAlign.swift
//
//  Collection of shortcuts to create autolayout constraints.
//

import UIKit

class TegAutolayoutConstraints {
  class func centerX(viewOne: UIView, viewTwo: UIView,
    constraintContainer: UIView) -> [NSLayoutConstraint] {
      
      return center(viewOne, viewTwo: viewTwo, constraintContainer: constraintContainer, vertically: false)
  }
  
  class func centerY(viewOne: UIView, viewTwo: UIView,
    constraintContainer: UIView) -> [NSLayoutConstraint] {
      
      return center(viewOne, viewTwo: viewTwo, constraintContainer: constraintContainer, vertically: true)
  }
  
  private class func center(viewOne: UIView, viewTwo: UIView,
    constraintContainer: UIView, vertically: Bool = false) -> [NSLayoutConstraint] {
      
      let attribute = vertically ? NSLayoutAttribute.CenterY : NSLayoutAttribute.CenterX
      
      let constraint = NSLayoutConstraint(
        item: viewOne,
        attribute: attribute,
        relatedBy: NSLayoutRelation.Equal,
        toItem: viewTwo,
        attribute: attribute,
        multiplier: 1,
        constant: 0)
      
      constraintContainer.addConstraint(constraint)
      
      return [constraint]
  }
  
  class func alignSameAttributes(item: AnyObject, toItem: AnyObject,
    constraintContainer: UIView, attribute: NSLayoutAttribute, margin: CGFloat = 0) -> [NSLayoutConstraint] {
      
      let constraint = NSLayoutConstraint(
        item: item,
        attribute: attribute,
        relatedBy: NSLayoutRelation.Equal,
        toItem: toItem,
        attribute: attribute,
        multiplier: 1,
        constant: margin)
      
      constraintContainer.addConstraint(constraint)
      
      return [constraint]
  }
  
  class func alignVerticallyToLayoutGuide(item: AnyObject, onTop: Bool,
    layoutGuide: UILayoutSupport, constraintContainer: UIView,
    margin: CGFloat = 0) -> [NSLayoutConstraint] {
      
    let constraint = NSLayoutConstraint(
      item: layoutGuide,
      attribute: onTop ? NSLayoutAttribute.Bottom : NSLayoutAttribute.Top,
      relatedBy: NSLayoutRelation.Equal,
      toItem: item,
      attribute: onTop ? NSLayoutAttribute.Top : NSLayoutAttribute.Bottom,
      multiplier: 1,
      constant: margin)
    
    constraintContainer.addConstraint(constraint)
    
    return [constraint]
  }
  
  class func aspectRatio(view: UIView, ratio: CGFloat) {
    let constraint = NSLayoutConstraint(
      item: view,
      attribute: NSLayoutAttribute.Width,
      relatedBy: NSLayoutRelation.Equal,
      toItem: view,
      attribute: NSLayoutAttribute.Height,
      multiplier: ratio,
      constant: 0)
    
    view.addConstraint(constraint)
  }
  
  class func fillParent(view: UIView, parentView: UIView, margin: CGFloat = 0, vertically: Bool) {
    var marginFormat = ""
    
    if margin != 0 {
      marginFormat = "-\(margin)-"
    }
    
    var format = "|\(marginFormat)[view]\(marginFormat)|"
    
    if vertically {
      format = "V:" + format
    }
    
    let constraints = NSLayoutConstraint.constraintsWithVisualFormat(format,
      options: [], metrics: nil,
      views: ["view": view])
    
    parentView.addConstraints(constraints)
  }
  
  class func viewsNextToEachOther(views: [UIView],
    constraintContainer: UIView, margin: CGFloat = 0,
    vertically: Bool = false) -> [NSLayoutConstraint] {
      
    if views.count < 2 { return []  }
      
    var constraints = [NSLayoutConstraint]()
      
    for (index, view) in views.enumerate() {
      if index >= views.count - 1 { break }
      
      let viewTwo = views[index + 1]
      
      constraints += twoViewsNextToEachOther(view, viewTwo: viewTwo,
        constraintContainer: constraintContainer, margin: margin, vertically: vertically)
    }
      
    return constraints
  }
  
  class func twoViewsNextToEachOther(viewOne: UIView, viewTwo: UIView,
    constraintContainer: UIView, margin: CGFloat = 0,
    vertically: Bool = false) -> [NSLayoutConstraint] {
      
    var marginFormat = ""
    
    if margin != 0 {
      marginFormat = "-\(margin)-"
    }
    
    var format = "[viewOne]\(marginFormat)[viewTwo]"
    
    if vertically {
      format = "V:" + format
    }
    
    let constraints = NSLayoutConstraint.constraintsWithVisualFormat(format,
      options: [], metrics: nil,
      views: [ "viewOne": viewOne, "viewTwo": viewTwo ])
        
    constraintContainer.addConstraints(constraints)
    
    return constraints
  }
  
  class func equalWidth(viewOne: UIView, viewTwo: UIView,
    constraintContainer: UIView) -> [NSLayoutConstraint] {
      
    let constraints = NSLayoutConstraint.constraintsWithVisualFormat("[viewOne(==viewTwo)]",
        options: [], metrics: nil,
        views: ["viewOne": viewOne, "viewTwo": viewTwo])
          
          
    constraintContainer.addConstraints(constraints)
    
    return constraints
  }
  
  class func height(view: UIView, value: CGFloat) -> [NSLayoutConstraint] {
    return widthOrHeight(view, value: value, isWidth: false)
  }
  
  class func width(view: UIView, value: CGFloat) -> [NSLayoutConstraint] {
    return widthOrHeight(view, value: value, isWidth: true)
  }
  
  private class func widthOrHeight(view: UIView, value: CGFloat,
    isWidth: Bool) -> [NSLayoutConstraint] {
    
    let attribute = isWidth ? NSLayoutAttribute.Width : NSLayoutAttribute.Height
      
    let constraint = NSLayoutConstraint(
      item: view,
      attribute: attribute,
      relatedBy: NSLayoutRelation.Equal,
      toItem: nil,
      attribute: NSLayoutAttribute.NotAnAttribute,
      multiplier: 1,
      constant: value)
    
    view.addConstraint(constraint)
    
    return [constraint]
  }
}


